/**
 * Ïã§ÏãúÍ∞Ñ ÏΩîÎìú Î∂ÑÏÑù Î∞è ÏµúÏ†ÅÌôî ÏãúÏä§ÌÖú
 */
import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';
import { CodeGenerator } from '../ai/CodeGenerator.js';

export class CodeAnalyzer {
  constructor() {
    this.codeGenerator = new CodeGenerator();
    this.analysisCache = new Map();
    this.watchedFiles = new Set();
    this.analysisResults = new Map();
  }

  /**
   * ÌîÑÎ°úÏ†ùÌä∏ Ï†ÑÏ≤¥ Î∂ÑÏÑù
   */
  async analyzeProject(projectPath) {
    try {
      console.log('üîç ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù ÏãúÏûë...');
      
      const analysis = {
        projectPath,
        timestamp: new Date().toISOString(),
        structure: await this.analyzeProjectStructure(projectPath),
        codeQuality: await this.analyzeCodeQuality(projectPath),
        dependencies: await this.analyzeDependencies(projectPath),
        security: await this.analyzeSecurityIssues(projectPath),
        performance: await this.analyzePerformance(projectPath),
        suggestions: []
      };
      
      // AI Í∏∞Î∞ò Ï¢ÖÌï© Î∂ÑÏÑù
      analysis.aiInsights = await this.generateAIInsights(analysis);
      
      // Í∞úÏÑ† Ï†úÏïà ÏÉùÏÑ±
      analysis.suggestions = this.generateImprovementSuggestions(analysis);
      
      console.log('‚úÖ ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù ÏôÑÎ£å');
      return analysis;
      
    } catch (error) {
      console.error('‚ùå ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù Ïã§Ìå®:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ Î∂ÑÏÑù
   */
  async analyzeProjectStructure(projectPath) {
    const structure = {
      totalFiles: 0,
      totalLines: 0,
      fileTypes: {},
      directories: [],
      largestFiles: [],
      duplicates: []
    };

    try {
      const files = await this.getAllFiles(projectPath);
      structure.totalFiles = files.length;
      
      for (const filePath of files) {
        const ext = path.extname(filePath);
        const stats = await fs.stat(filePath);
        
        // ÌååÏùº ÌÉÄÏûÖÎ≥Ñ ÌÜµÍ≥Ñ
        structure.fileTypes[ext] = (structure.fileTypes[ext] || 0) + 1;
        
        // ÏΩîÎìú ÌååÏùºÎßå ÎùºÏù∏ Ïàò Í≥ÑÏÇ∞
        if (this.isCodeFile(ext)) {
          const content = await fs.readFile(filePath, 'utf-8');
          const lines = content.split('\n').length;
          structure.totalLines += lines;
          
          // ÌÅ∞ ÌååÏùº Ï∂îÏ†Å
          if (lines > 200) {
            structure.largestFiles.push({
              path: filePath,
              lines,
              size: stats.size
            });
          }
        }
      }
      
      // ÌÅ∞ ÌååÏùº Ï†ïÎ†¨
      structure.largestFiles.sort((a, b) => b.lines - a.lines);
      structure.largestFiles = structure.largestFiles.slice(0, 10);
      
      return structure;
    } catch (error) {
      console.error('Íµ¨Ï°∞ Î∂ÑÏÑù Ïã§Ìå®:', error);
      return structure;
    }
  }

  /**
   * ÏΩîÎìú ÌíàÏßà Î∂ÑÏÑù
   */
  async analyzeCodeQuality(projectPath) {
    const quality = {
      overallScore: 0,
      metrics: {
        complexity: 0,
        maintainability: 0,
        readability: 0,
        testCoverage: 0
      },
      issues: [],
      files: []
    };

    try {
      const codeFiles = await this.getCodeFiles(projectPath);
      let totalScore = 0;
      let fileCount = 0;

      for (const filePath of codeFiles) {
        const content = await fs.readFile(filePath, 'utf-8');
        const analysis = await this.codeGenerator.analyzeCode(content, this.getLanguageFromFile(filePath));
        
        quality.files.push({
          path: filePath,
          analysis
        });
        
        totalScore += analysis.quality.score;
        fileCount++;
        
        // ÌíàÏßà Ïù¥Ïäà ÏàòÏßë
        if (analysis.quality.score < 60) {
          quality.issues.push({
            file: filePath,
            type: 'low_quality',
            score: analysis.quality.score,
            message: `ÏΩîÎìú ÌíàÏßàÏù¥ ÎÇÆÏäµÎãàÎã§ (${analysis.quality.grade})`
          });
        }
        
        if (analysis.complexity.level === 'high') {
          quality.issues.push({
            file: filePath,
            type: 'high_complexity',
            complexity: analysis.complexity.cyclomatic,
            message: `ÎÜíÏùÄ Î≥µÏû°ÎèÑ (ÏàúÌôò Î≥µÏû°ÎèÑ: ${analysis.complexity.cyclomatic})`
          });
        }
      }
      
      quality.overallScore = fileCount > 0 ? Math.round(totalScore / fileCount) : 0;
      
      // Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞
      quality.metrics.complexity = this.calculateAverageComplexity(quality.files);
      quality.metrics.maintainability = this.calculateMaintainabilityIndex(quality.files);
      quality.metrics.readability = this.calculateReadabilityScore(quality.files);
      
      return quality;
    } catch (error) {
      console.error('ÌíàÏßà Î∂ÑÏÑù Ïã§Ìå®:', error);
      return quality;
    }
  }

  /**
   * ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù
   */
  async analyzeDependencies(projectPath) {
    const dependencies = {
      total: 0,
      outdated: [],
      vulnerabilities: [],
      unused: [],
      licenses: {},
      size: 0
    };

    try {
      // package.json ÌôïÏù∏
      const packageJsonPath = path.join(projectPath, 'package.json');
      const packageJsonExists = await fs.access(packageJsonPath).then(() => true).catch(() => false);
      
      if (packageJsonExists) {
        const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
        
        const allDeps = {
          ...packageJson.dependencies || {},
          ...packageJson.devDependencies || {}
        };
        
        dependencies.total = Object.keys(allDeps).length;
        
        // npm audit Ïã§Ìñâ (Ï∑®ÏïΩÏ†ê Í≤ÄÏÇ¨)
        try {
          process.chdir(projectPath);
          const auditResult = execSync('npm audit --json', { encoding: 'utf-8' });
          const audit = JSON.parse(auditResult);
          
          if (audit.vulnerabilities) {
            Object.entries(audit.vulnerabilities).forEach(([name, vuln]) => {
              dependencies.vulnerabilities.push({
                name,
                severity: vuln.severity,
                title: vuln.title,
                url: vuln.url
              });
            });
          }
        } catch (auditError) {
          console.log('npm audit Ïã§Ìñâ Î∂àÍ∞Ä (Ï†ïÏÉÅÏ†ÅÏûÑ)');
        }
        
        // Ïò§ÎûòÎêú Ìå®ÌÇ§ÏßÄ ÌôïÏù∏
        try {
          const outdatedResult = execSync('npm outdated --json', { encoding: 'utf-8' });
          if (outdatedResult) {
            const outdated = JSON.parse(outdatedResult);
            Object.entries(outdated).forEach(([name, info]) => {
              dependencies.outdated.push({
                name,
                current: info.current,
                wanted: info.wanted,
                latest: info.latest
              });
            });
          }
        } catch (outdatedError) {
          console.log('npm outdated Ïã§Ìñâ Î∂àÍ∞Ä (Ï†ïÏÉÅÏ†ÅÏûÑ)');
        }
      }
      
      // requirements.txt ÌôïÏù∏ (Python)
      const requirementsPath = path.join(projectPath, 'requirements.txt');
      const requirementsExists = await fs.access(requirementsPath).then(() => true).catch(() => false);
      
      if (requirementsExists) {
        const requirements = await fs.readFile(requirementsPath, 'utf-8');
        const pythonDeps = requirements.split('\n').filter(line => line.trim() && !line.startsWith('#'));
        dependencies.total += pythonDeps.length;
      }
      
      return dependencies;
    } catch (error) {
      console.error('ÏùòÏ°¥ÏÑ± Î∂ÑÏÑù Ïã§Ìå®:', error);
      return dependencies;
    }
  }

  /**
   * Î≥¥Ïïà Ïù¥Ïäà Î∂ÑÏÑù
   */
  async analyzeSecurityIssues(projectPath) {
    const security = {
      score: 100,
      issues: [],
      categories: {
        authentication: [],
        dataExposure: [],
        injection: [],
        configuration: []
      }
    };

    try {
      const codeFiles = await this.getCodeFiles(projectPath);
      
      for (const filePath of codeFiles) {
        const content = await fs.readFile(filePath, 'utf-8');
        const issues = this.detectSecurityIssues(content, filePath);
        security.issues.push(...issues);
      }
      
      // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Î∂ÑÎ•ò
      security.issues.forEach(issue => {
        if (security.categories[issue.category]) {
          security.categories[issue.category].push(issue);
        }
      });
      
      // Î≥¥Ïïà Ï†êÏàò Í≥ÑÏÇ∞
      const severityWeights = { high: 20, medium: 10, low: 5 };
      const deduction = security.issues.reduce((sum, issue) => {
        return sum + (severityWeights[issue.severity] || 5);
      }, 0);
      
      security.score = Math.max(0, 100 - deduction);
      
      return security;
    } catch (error) {
      console.error('Î≥¥Ïïà Î∂ÑÏÑù Ïã§Ìå®:', error);
      return security;
    }
  }

  /**
   * ÏÑ±Îä• Î∂ÑÏÑù
   */
  async analyzePerformance(projectPath) {
    const performance = {
      score: 0,
      issues: [],
      metrics: {
        bundleSize: 0,
        loadTime: 0,
        memoryUsage: 0
      },
      optimizations: []
    };

    try {
      const codeFiles = await this.getCodeFiles(projectPath);
      let totalSize = 0;
      
      for (const filePath of codeFiles) {
        const stats = await fs.stat(filePath);
        totalSize += stats.size;
        
        const content = await fs.readFile(filePath, 'utf-8');
        const perfIssues = this.detectPerformanceIssues(content, filePath);
        performance.issues.push(...perfIssues);
      }
      
      performance.metrics.bundleSize = totalSize;
      
      // ÏÑ±Îä• ÏµúÏ†ÅÌôî Ï†úÏïà
      performance.optimizations = this.generatePerformanceOptimizations(performance.issues);
      
      // ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞
      const issueCount = performance.issues.length;
      performance.score = Math.max(0, 100 - (issueCount * 5));
      
      return performance;
    } catch (error) {
      console.error('ÏÑ±Îä• Î∂ÑÏÑù Ïã§Ìå®:', error);
      return performance;
    }
  }

  /**
   * Î≥¥Ïïà Ïù¥Ïäà Í∞êÏßÄ
   */
  detectSecurityIssues(content, filePath) {
    const issues = [];
    
    // SQL Ïù∏Ï†ùÏÖò ÏúÑÌóò
    if (/query\s*\+|SELECT.*\+|INSERT.*\+/.test(content)) {
      issues.push({
        file: filePath,
        type: 'sql_injection',
        category: 'injection',
        severity: 'high',
        message: 'SQL Ïù∏Ï†ùÏÖò Ï∑®ÏïΩÏ†ê Í∞ÄÎä•ÏÑ±',
        line: this.findLineNumber(content, /query\s*\+|SELECT.*\+|INSERT.*\+/)
      });
    }
    
    // XSS ÏúÑÌóò
    if (/innerHTML\s*=|document\.write/.test(content)) {
      issues.push({
        file: filePath,
        type: 'xss',
        category: 'injection',
        severity: 'medium',
        message: 'XSS Ï∑®ÏïΩÏ†ê Í∞ÄÎä•ÏÑ±',
        line: this.findLineNumber(content, /innerHTML\s*=|document\.write/)
      });
    }
    
    // ÌïòÎìúÏΩîÎî©Îêú ÎπÑÎ∞ÄÎ≤àÌò∏/API ÌÇ§
    if (/password\s*=\s*['"][^'"]{3,}['"]|api_?key\s*=\s*['"][^'"]{10,}['"]/.test(content)) {
      issues.push({
        file: filePath,
        type: 'hardcoded_secrets',
        category: 'dataExposure',
        severity: 'high',
        message: 'ÌïòÎìúÏΩîÎî©Îêú ÎπÑÎ∞ÄÎ≤àÌò∏ ÎòêÎäî API ÌÇ§',
        line: this.findLineNumber(content, /password\s*=\s*['"]|api_?key\s*=\s*['"]/)
      });
    }
    
    // HTTPS ÎØ∏ÏÇ¨Ïö©
    if (/http:\/\/(?!localhost|127\.0\.0\.1)/.test(content)) {
      issues.push({
        file: filePath,
        type: 'insecure_http',
        category: 'configuration',
        severity: 'medium',
        message: 'HTTPS ÎåÄÏã† HTTP ÏÇ¨Ïö©',
        line: this.findLineNumber(content, /http:\/\/(?!localhost|127\.0\.0\.1)/)
      });
    }
    
    return issues;
  }

  /**
   * ÏÑ±Îä• Ïù¥Ïäà Í∞êÏßÄ
   */
  detectPerformanceIssues(content, filePath) {
    const issues = [];
    
    // ÎπÑÌö®Ïú®Ï†ÅÏù∏ Î£®ÌîÑ
    if (/for.*in.*{[\s\S]*for.*in/.test(content)) {
      issues.push({
        file: filePath,
        type: 'nested_loops',
        severity: 'medium',
        message: 'Ï§ëÏ≤©Îêú Î£®ÌîÑÎ°ú Ïù∏Ìïú ÏÑ±Îä• Ï†ÄÌïò Í∞ÄÎä•ÏÑ±',
        line: this.findLineNumber(content, /for.*in.*{[\s\S]*for.*in/)
      });
    }
    
    // ÎåÄÏö©Îüâ ÎèôÍ∏∞ ÌååÏùº ÏùΩÍ∏∞
    if (/readFileSync|writeFileSync/.test(content)) {
      issues.push({
        file: filePath,
        type: 'sync_file_operations',
        severity: 'medium',
        message: 'ÎèôÍ∏∞ ÌååÏùº ÏûëÏóÖÏúºÎ°ú Ïù∏Ìïú Î∏îÎ°úÌÇπ',
        line: this.findLineNumber(content, /readFileSync|writeFileSync/)
      });
    }
    
    // Î©îÎ™®Î¶¨ ÎàÑÏàò Í∞ÄÎä•ÏÑ±
    if (/setInterval(?!.*clearInterval)|addEventListener(?!.*removeEventListener)/.test(content)) {
      issues.push({
        file: filePath,
        type: 'memory_leak',
        severity: 'medium',
        message: 'Î©îÎ™®Î¶¨ ÎàÑÏàò Í∞ÄÎä•ÏÑ± (Ï†ïÎ¶¨ÎêòÏßÄ ÏïäÎäî Ïù¥Î≤§Ìä∏/ÌÉÄÏù¥Î®∏)',
        line: this.findLineNumber(content, /setInterval(?!.*clearInterval)|addEventListener(?!.*removeEventListener)/)
      });
    }
    
    return issues;
  }

  /**
   * AI Í∏∞Î∞ò Ï¢ÖÌï© Î∂ÑÏÑù
   */
  async generateAIInsights(analysis) {
    try {
      const prompt = `Îã§Ïùå ÌîÑÎ°úÏ†ùÌä∏ Î∂ÑÏÑù Í≤∞Í≥ºÎ•º Î∞îÌÉïÏúºÎ°ú Ï¢ÖÌï©Ï†ÅÏù∏ Ïù∏ÏÇ¨Ïù¥Ìä∏ÏôÄ Í∞úÏÑ† Î∞©ÏïàÏùÑ Ï†úÏãúÌï¥Ï£ºÏÑ∏Ïöî:

ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞:
- Ï¥ù ÌååÏùº Ïàò: ${analysis.structure.totalFiles}
- Ï¥ù ÎùºÏù∏ Ïàò: ${analysis.structure.totalLines}
- Ï£ºÏöî ÌååÏùº ÌÉÄÏûÖ: ${Object.keys(analysis.structure.fileTypes).join(', ')}

ÏΩîÎìú ÌíàÏßà:
- Ï†ÑÏ≤¥ Ï†êÏàò: ${analysis.codeQuality.overallScore}/100
- Ïù¥Ïäà Ïàò: ${analysis.codeQuality.issues.length}

Î≥¥Ïïà:
- Î≥¥Ïïà Ï†êÏàò: ${analysis.security.score}/100
- Î≥¥Ïïà Ïù¥Ïäà: ${analysis.security.issues.length}Í∞ú

ÏÑ±Îä•:
- ÏÑ±Îä• Ï†êÏàò: ${analysis.performance.score}/100
- Î≤àÎì§ ÌÅ¨Í∏∞: ${Math.round(analysis.performance.metrics.bundleSize / 1024)}KB

Ï£ºÏöî Í∞úÏÑ† ÏÇ¨Ìï≠Í≥º Ïö∞ÏÑ†ÏàúÏúÑÎ•º Ï†úÏãúÌï¥Ï£ºÏÑ∏Ïöî.`;

      const insights = await this.codeGenerator.aiService.generateText(prompt);
      return insights;
    } catch (error) {
      return 'ÌòÑÏû¨ AI Ïù∏ÏÇ¨Ïù¥Ìä∏Î•º ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÏßÅÏ†ë Í≤ÄÌÜ†Ìï¥Ï£ºÏÑ∏Ïöî.';
    }
  }

  /**
   * Í∞úÏÑ† Ï†úÏïà ÏÉùÏÑ±
   */
  generateImprovementSuggestions(analysis) {
    const suggestions = [];
    
    // ÏΩîÎìú ÌíàÏßà Í∞úÏÑ†
    if (analysis.codeQuality.overallScore < 70) {
      suggestions.push({
        category: 'code_quality',
        priority: 'high',
        title: 'ÏΩîÎìú ÌíàÏßà Í∞úÏÑ†',
        description: 'Ï†ÑÏ≤¥ ÏΩîÎìú ÌíàÏßà Ï†êÏàòÍ∞Ä ÎÇÆÏäµÎãàÎã§. Î¶¨Ìå©ÌÜ†ÎßÅÏùÑ Í≥†Î†§ÌïòÏÑ∏Ïöî.',
        actions: [
          'ESLint/Prettier ÏÑ§Ï†ï Ï†êÍ≤Ä',
          'Ìï®Ïàò Í∏∏Ïù¥ Îã®Ï∂ï',
          'Ï£ºÏÑù Ï∂îÍ∞Ä',
          'ÏóêÎü¨ Ï≤òÎ¶¨ Í∞ïÌôî'
        ]
      });
    }
    
    // Î≥¥Ïïà Í∞úÏÑ†
    if (analysis.security.score < 80) {
      suggestions.push({
        category: 'security',
        priority: 'high',
        title: 'Î≥¥Ïïà Í∞ïÌôî',
        description: 'Î≥¥Ïïà Ïù¥ÏäàÍ∞Ä Î∞úÍ≤¨ÎêòÏóàÏäµÎãàÎã§.',
        actions: [
          'ÌïòÎìúÏΩîÎî©Îêú ÎπÑÎ∞ÄÎ≤àÌò∏ Ï†úÍ±∞',
          'HTTPS ÏÇ¨Ïö©',
          'ÏûÖÎ†•Í∞í Í≤ÄÏ¶ù Í∞ïÌôî',
          'Î≥¥Ïïà ÏùòÏ°¥ÏÑ± ÏóÖÎç∞Ïù¥Ìä∏'
        ]
      });
    }
    
    // ÏÑ±Îä• ÏµúÏ†ÅÌôî
    if (analysis.performance.score < 80) {
      suggestions.push({
        category: 'performance',
        priority: 'medium',
        title: 'ÏÑ±Îä• ÏµúÏ†ÅÌôî',
        description: 'ÏÑ±Îä• Í∞úÏÑ†Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.',
        actions: analysis.performance.optimizations
      });
    }
    
    // ÏùòÏ°¥ÏÑ± Í¥ÄÎ¶¨
    if (analysis.dependencies.outdated.length > 0) {
      suggestions.push({
        category: 'dependencies',
        priority: 'medium',
        title: 'ÏùòÏ°¥ÏÑ± ÏóÖÎç∞Ïù¥Ìä∏',
        description: `${analysis.dependencies.outdated.length}Í∞úÏùò Ïò§ÎûòÎêú Ìå®ÌÇ§ÏßÄÍ∞Ä ÏûàÏäµÎãàÎã§.`,
        actions: [
          'npm update Ïã§Ìñâ',
          'Ï£ºÏöî ÏóÖÎç∞Ïù¥Ìä∏ ÌôïÏù∏',
          'Ï∑®ÏïΩÏ†ê Ìå®Ïπò'
        ]
      });
    }
    
    return suggestions;
  }

  /**
   * ÏÑ±Îä• ÏµúÏ†ÅÌôî Ï†úÏïà ÏÉùÏÑ±
   */
  generatePerformanceOptimizations(issues) {
    const optimizations = [];
    
    issues.forEach(issue => {
      switch (issue.type) {
        case 'nested_loops':
          optimizations.push('Ï§ëÏ≤© Î£®ÌîÑÎ•º Map/Set ÏûêÎ£åÍµ¨Ï°∞Î°ú ÏµúÏ†ÅÌôî');
          break;
        case 'sync_file_operations':
          optimizations.push('ÎèôÍ∏∞ ÌååÏùº ÏûëÏóÖÏùÑ ÎπÑÎèôÍ∏∞Î°ú Î≥ÄÍ≤Ω');
          break;
        case 'memory_leak':
          optimizations.push('Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÏôÄ ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨ Î°úÏßÅ Ï∂îÍ∞Ä');
          break;
      }
    });
    
    return [...new Set(optimizations)]; // Ï§ëÎ≥µ Ï†úÍ±∞
  }

  // Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìúÎì§
  async getAllFiles(dir, files = []) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory() && !this.shouldSkipDirectory(entry.name)) {
        await this.getAllFiles(fullPath, files);
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }
    
    return files;
  }

  async getCodeFiles(projectPath) {
    const allFiles = await this.getAllFiles(projectPath);
    return allFiles.filter(file => this.isCodeFile(path.extname(file)));
  }

  isCodeFile(ext) {
    const codeExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.c', '.cs', '.php', '.rb', '.go'];
    return codeExtensions.includes(ext.toLowerCase());
  }

  shouldSkipDirectory(name) {
    const skipDirs = ['node_modules', '.git', 'dist', 'build', '__pycache__', '.pytest_cache', 'venv'];
    return skipDirs.includes(name);
  }

  getLanguageFromFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const langMap = {
      '.js': 'javascript',
      '.jsx': 'javascript',
      '.ts': 'typescript',
      '.tsx': 'typescript',
      '.py': 'python',
      '.java': 'java',
      '.cpp': 'cpp',
      '.c': 'c',
      '.cs': 'csharp',
      '.php': 'php',
      '.rb': 'ruby',
      '.go': 'go'
    };
    return langMap[ext] || 'text';
  }

  findLineNumber(content, pattern) {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (pattern.test(lines[i])) {
        return i + 1;
      }
    }
    return 1;
  }

  calculateAverageComplexity(files) {
    if (files.length === 0) return 0;
    const total = files.reduce((sum, file) => sum + file.analysis.complexity.cyclomatic, 0);
    return Math.round(total / files.length);
  }

  calculateMaintainabilityIndex(files) {
    // Í∞ÑÎã®Ìïú Ïú†ÏßÄÎ≥¥ÏàòÏÑ± ÏßÄÏàò Í≥ÑÏÇ∞
    if (files.length === 0) return 0;
    const avgScore = files.reduce((sum, file) => sum + file.analysis.quality.score, 0) / files.length;
    return Math.round(avgScore * 0.8); // ÌíàÏßà Ï†êÏàòÏùò 80%Î•º Ïú†ÏßÄÎ≥¥ÏàòÏÑ±ÏúºÎ°ú Í≥ÑÏÇ∞
  }

  calculateReadabilityScore(files) {
    // Í∞ÄÎèÖÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ (Ï£ºÏÑù ÎπÑÏú®, Ìï®Ïàò Í∏∏Ïù¥ Îì± Í≥†Î†§)
    if (files.length === 0) return 0;
    
    let totalScore = 0;
    files.forEach(file => {
      const commentFactor = file.analysis.quality.factors.comments || 0;
      const functionFactor = file.analysis.quality.factors.functionLength || 0;
      const namingFactor = file.analysis.quality.factors.naming || 0;
      
      const readabilityScore = (commentFactor + functionFactor + namingFactor) / 3;
      totalScore += readabilityScore;
    });
    
    return Math.round(totalScore / files.length);
  }
}

export default CodeAnalyzer;
